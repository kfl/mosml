2000-01-18:

+ The amlazy file Data.sml containing a structure called Data: parse
  as AnonStruct, then resolve in the compiler

* Avoid shift/reduce and reduce/reduce conflicts in the parser.

+ Documentation: 

  - manual
  - syntax

+ Emitcode: switch larger than 256 ?  OK because the switch
  compilation in Back breaks switches into chunks of size < 256

+ Kit: It is functor Parse in k42.sml that causes trouble --- even
  when actions in k32.sml is commented out.  Functor Parse is declared
  in k35.sml.  More precisely, the application of functor GrammarUtils
  inside the Parse functor in k35.sml:

    structure GrammarUtils =
      GrammarUtils (structure TopdecGrammar = TopdecGrammar
		    structure LexBasics = LexBasics
		    structure ParseInfo = ParseInfo
		    structure Report = Report
		    structure PrettyPrint = PrettyPrint
		    structure Crash = Crash
		      )
  Functor GrammarUtils is declared in k32.sml.
 
  Problem: open of local decs.

+ Back.sml -- array size 65000 -> 4000 (used only for the locals of 
  the init code)

+ Size of mosmllex and mosmllnk: avoid linking in Types

+ exnName and exnMessage -> runtime

  prim_val exnname : exn -> string = 1 "sml_exnname";

  prim_val exnMessage : exn -> string = 1 "sml_exnmessage";

+ Add documentation to General.fke

+ Implement sharing of literals (strings, reals, etc) as globals cf
  the hol98 and cholera problems: Updated Patch and Reloc and Code_dec
  and Link.

+ Cleanup of the dynlibs; moved stable structures to src/mosmllib

+ Fix mgd dynlib to use new GD package and PNG format.

+ Fix mosmllib/test/Makefile to create sym- and hardlinks as needed

+ Fix errormessage in compiler/Emitcode

+ Fix printing of overloaded ops to distinguish num, numtxt etc

* Fix exn tag access under lambda in Match.sml

* In general, compile better code for accessing subvalues in matches.
  However, should never evaluate accesses that aren't needed (safe but
  unnecessarily slow). The matching function may return an `envelope'
  of let-bindings?

+ Include runtime system *.h files in distribution (for the sake of
  user-written C code and dynlibs)

* Perhaps fix mgdbm to use new GDBM?

+ Inexhaustive and redundant excon matches -- why not reported correctly?
  Because EExn carries IdInfo as argument, and that includes the location 
  of the identifier.  Of course no two identifier occurrences have the same 
  location.  How fix it?  Translate the exnname accesses early, and
  compare the access paths (the lambda code): equal access paths must
  produce equal string refs...

* Add an Odbc interface to unixODBC.
  Later; possibly Thomas Iversen, DIKU/KVL.

+ .h files in mosml/include

+ make dynlibs/* refer to mosml/include

+ move .so files from mosml/bin to mosml/lib

+ strange bug in dynlibs/interface/ for Solaris.  Crashes.  Fails
  test7, because it doesn't pass the fifth argument (a boolean)
  correctly.  test 7 works if the number of arguments is reduced to 4.
  test10 fails as well, why?  NON-BUG.  A symbolic link had been
  extended by recursive file copying.

+ Non-blocking IO in TextIO.  input calls fast_input, which is
  io.input in the runtime.  It calls getblock, which may call
  really_read if necessary to obtain data not in the buffer; and
  really_read calls Unix read.  This will raise sys_error in case Unix
  read fails (cannot obtain any data).

  Two solutions: (1) handle the SysError (and check that it is
  EAGAIN), or (2) add an extra parameter to really_read so that it
  avoids raising the SysError.

  (1) is inefficient, 

  (2) may be done as follows: Add a new boolean parameter `nonblocking' to
  really_read.  If it is true, then use fcntl to change to
  non-blocking (and back), and if read fails, return -1 instead of
  raising sys_error.

  void nonblocking_mode(int fd, int nonblocking) {
    int retcode = fcntl(fd, F_GETFL);
    if (retcode != -1) {
      if (blocking) 
        retcode = fcntl(fd, F_SETFL, retcode | O_NONBLOCK);
      else
        retcode = fcntl(fd, F_SETFL, retcode & (~O_NONBLOCK));
    }
    if (retcode == -1)
      failwith("set_blocking_io");
  }

  static int really_read(int fd, char * p, unsigned n, int nonblocking) {
    if (nonblocking)
      nonblocking_mode(fd, TRUE);		/* set non-blocking   */

    ...

    leave_blocking_section();
    if (nonblocking) {
      nonblocking_mode(fd, FALSE);		/* unset non-blocking */
      if (retcode == -1 && errno != EAGAIN)
        sys_error(NULL);
    } else if (retcode == -1)
        sys_error(NULL);
    return retcode;
  }

  Function input_scan_line must call really_read with nonblocking = false.

  Add a new parameter nonblocking to getblock.  It must be passed on
  to really_read.  Getblock must check whether really_read returns
  -1, which should be treated the same as 0, except that it does not mean 
  end of file:

int getblock(struct channel * channel, char * p, unsigned n, 
   int nonblocking)
{
  unsigned m, l;

  m = channel->max - channel->curr;
  if (n <= m) {
    bcopy(channel->curr, p, n);
    channel->curr += n;
    return n;
  } else if (m > 0) {
    bcopy(channel->curr, p, m);
    channel->curr += m;
    return m;
  } else if (n < IO_BUFFER_SIZE) {
    l = really_read(channel->fd, channel->buff, IO_BUFFER_SIZE, nonblocking);
    if (l == -1) /* Non-blocking read returned no data */ 
      return -1;
    else {
      channel->offset += l;
      channel->max = channel->buff + l;
      if (n > l) n = l;
      bcopy(channel->buff, p, n);
      channel->curr = channel->buff + n;
      return n;
    }
  } else {
    channel->curr = channel->buff;
    channel->max = channel->buff;
    l = really_read(channel->fd, p, n, nonblocking);
    if (l == -1)	/* Non-blocking read returned no data */ 
      return -1;
    else {
      channel->offset += l;
      return l;
    }
  }
}

Function input will just call getblock with non-blocking = FALSE:

value input(value channel, value buff, value start, value length) /* ML */
{
  return Val_long(getblock((struct channel *) channel,
                           &Byte(buff, Long_val(start)),
                           (unsigned) Long_val(length),
	                   /* nonblocking = */ FALSE));
}



Make really_getblock call getblock with nonblocking=FALSE:

int really_getblock(struct channel * chan, char * p, unsigned long n)
{
  unsigned r;
  while (n > 0) {
    r = (unsigned)getblock(chan, p, (unsigned) n, /* nonblocking = */ FALSE);
    if (r == 0) return 0;
    p += r;
    n -= r;
  }
  return 1;
}


  Add a new function input_nonblocking, which will call getblock with
  nonblocking=TRUE.  Returns NONE if getblock returns -1, otherwise 
  returns SOME 

value input_nonblocking(value channel, value buff, value start, value length) /* ML */
{ int n = getblock((struct channel *) channel,
                   &Byte(buff, Long_val(start)),
                   (unsigned) Long_val(length),
	           /* nonblocking = */ TRUE));
  if (n == -1)		/* Non-blocking read returned no data */ 
    return Val_NONE;
  else {
    value res = alloc(1, SOMEtag);
    Field(res, 0) = Val_long(n);
    return res;
  }
}

  
* 2000-03-15 Ken: Parametre til lexer-funktioner

  rule comment depth = parse ...

  for at kunne lave en rent funktionel lexing af indlejrede kommentarer.

+ 2000-03-28: Add a parser combinator module called Parse.
  Reimplement to use NONE/SOME instead of exceptions.  

  Add a formatting (unparsing) module called Format, using Olivier's
  ideas but avoiding repeated string concatenation (e.g. using a
  wseq-like structure) and having also a prsep style
  iterator-with-separator plus an prmap style iterator.

  May 2000: Decided to create mosml/example/parsercomb instead, as the
  parser combinator stuff seems too volatile.

+ Meta.fke;  remove Meta.system

+ Meta.fke; documentation

+ Lexing.sig

+ Parsing.sig

+ mosmllib/README

+ TextIO.scanStream -- get rid of cs? -- no: cannot

* Should gc time be subtracted from sys time?  (Timer, Mosml)

* Non-blocking IO should have a function canInput : int -> SOME int instead.

http://www.dina.kvl.dk/~sestoft/sml/imperative-io.html#IMPERATIVE_IO:SIG:SPEC

+ 2000-04-26: Michael Norrish: this crashes mosml 1.44 (and 1.99):

datatype 'a result =
    FIRST of 'a
  | SECOND of 'a;
val zz = case FIRST() of
    FIRST _ => ()
  | _ => ();     

while this works:

val z = case SECOND() of
    FIRST _ => ()
  | _ => ();

compiler/Rtvals.sml function prSeq; decode_obj thinks zz is a record
of length 1.  Why?  Has nothing to do with the polymorphism of result.

And really, the *representation* of the result is wrong; here zz
evaluates to false:

datatype result =
    FIRST of int
  | SECOND of int;
val zz = () = (case FIRST 1 of
    FIRST _ => ()
  | _ => ());     

The generated lambda code looks OK:

(prim (set_global Top.zz/3) 
	(prim (ccall2 sml_equal) (BLOCK 0:1 ) 
	      let (BLOCK 0:2 1) in 
	          ((switch:2 var:0 of 
	              0:2 : (BLOCK 0:1 )) 
	            statichandle (BLOCK 0:1 )) 
              end))

But the Kcode is wrong:

(BLOCK 0:1 ); 
push; 
(BLOCK 0:2 1); 
push; 
access 0; 
strictbranchifnot 1; 
branch 2; 
label 2; (BLOCK 0:1 ); 
label 1; pop 1; 
ccall2 sml_equal;
set_global Top.zz/1

Problem: the returned value is the argument of FIRST (which is a block
of length 1 in this case): nothing is pushed between strictbranchifnot
1 and branch 2.  Probably we forget to generate code to put unit in
the accumulator???  Back.sml line 721, optimization for the case where
the else-branch is a constunit ().  In that case, then other branches
are () too (but may have side effects).

The problem is caused by an optimization in the compiler backend, file
compiler/Back.sml line 721.  If you want to get rid of it, uncomment
this code:

         (* if ifnot = Lconst constUnit
            then let val (lbl, C1) = labelCode C
                 in Kstrictbranchifnot lbl :: compexp sz dp ifso C1 end
            else *)

I'm afraid I introduced this optimization in 1997.  The reasoning was
that if some branch of a switch evaluates to () : unit, then all
branches do, and they are evaluated only for their side effects.  Not
so.  

+ 2000-04-26: Constructor ordering.  Constructors should be sorted
alphabetically so that the ordering in datatype declarations doesn't
matter.  That is, this should elaborate:

     signature SIG = 
     sig
	 datatype 'a t = Bt | Ct of int
	 datatype 'a u = Cu of int | Bu 
     end

     structure S: SIG = 
     struct
	 datatype 'a t = Ct of int | Bt
	 datatype 'a u = Bu | Cu of int
     end

     structure G : sig datatype order = EQUAL | GREATER | LESS end = General;
     structure G : sig datatype order = GREATER | EQUAL | LESS end = General;

   - should reorder the pervasive datatypes (order and frag) in Types.sml:

and infoEQUAL = mkSML "EQUAL"
  { conArity=0,   conIsGreedy=false,   conTag=0,   conSpan=3,
    conType=sc_order }
and infoGREATER = mkSML "GREATER"
  { conArity=0,   conIsGreedy=false,   conTag=1,   conSpan=3,
    conType=sc_order }
and infoLESS = mkSML "LESS"
  { conArity=0,   conIsGreedy=false,   conTag=2,   conSpan=3,
    conType=sc_order }
and infoANTIQUOTE = mkSML "ANTIQUOTE"
  { conArity=1,   conIsGreedy=false,   conTag=0,   conSpan=2,
    conType= scheme_1u (fn a =>
      type_arrow a (type_frag a)) }
and infoQUOTE = mkSML "QUOTE"
  { conArity=1,   conIsGreedy=false,   conTag=1,   conSpan=2,
    conType= scheme_1u (fn a =>
      type_arrow type_string (type_frag a)) }

val initial_order_CE = ConEnv [infoEQUAL, infoGREATER, infoLESS];
val initial_frag_CE = ConEnv [infoANTIQUOTE, infoQUOTE];

   - fix the corresponding extraction code in Smlperv.sml:

val [infoFalse, infoTrue] = deConEnv initial_bool_CE
and [infoNil, infoCons]   = deConEnv initial_list_CE   (* NOTE: NOT sorted *)
and [infoNONE, infoSOME]  = deConEnv initial_option_CE
and [infoEQUAL, infoGREATER, infoLESS] = deConEnv initial_order_CE
and [infoANTIQUOTE, infoQUOTE] = deConEnv initial_frag_CE

   - do we need to change only the conTag fields, or also the
     initial_frag_CE etc (as above)?  Better order both.

   - the bool and option datatypes are sorted already

   - we do *not* fix the list datatype, since the constructors
     nil and :: may not be respecified or redeclared.

   - there is no corresponding runtime system code

   - should reorder the constructors in mosmllib:

	open_flag: BasicIO, BinIO, Nonstdio, TextIO
        and runtime/sys.c variable sys_open_flags

	dbresultstatus: Mysql, Postgres
        and dynlibs/mmysql/mmysql.c function db_resultstatus
        and dynlibs/mpq/mpq.c  

	parserInput and parserOutput: Parsing
        and the macroes START, TOKEN_READ, ... in parsing.c

   - mosmlyac must sort the tokens (the token datatype), because the 
     token tags are used as indexes into the parsetable, in parsing.c 
     line 97. 

   - dynlibs/interface/smlside.sml and cside.c: datatype t

   - sort constructors in declarations as well as specifications:
     uncomment line 1865 in Elab.sml, function elabDatBind (this takes 
     care of declarations as well as specifications).  

   - loading of libraries crashes because hashtables
     (Hasht) are used to represent signatures, and the mosmllib stuff 
     was compiled with one constructor ordering in Hasht, and are loaded 
     with another ordering.

   - Sort tokens in the parsers generated by mosmlyac.  Strangely, hand-
     sorting the tokens in compiler/Parser.grm makes mosmlcmp shorter
     by 1 K.  Should do the same to lex/Grammar.grm of course.  How
     make mosmlyac sort tokens?  Tokens are stored in the same
     (hashed, linked) symbol table as other grammar symbols.  The tag
     of a token is used only as an index into the table yytransl, it
     seems (parsing.c line 97).  Hence it suffices to (1) sort the  
     tokens (by symbol_value) and their adapt the indexes (symbol_value). 

   - constructor sorting affects user programs that use 
     Nonstdio.{input_value, output_value}, string_mlval, mlval_string, 
     and hence Polygdbm

Bootstrapping:

(1) Modify the core mosmllib .sml files and recompile.  The new
compiler must be run with a new runtime system.  
(2) Recompile with new compiler and runtime system.  Binaries should be 
identical.
(3) Fix Types and Smlperv.  Does not affect runtime.  Bootstrap.
(4) Enable constructor sorting, reorder Hasht.bucket constructors, 
sort tokens in grammar specifications.
(5) Fix Mysql, Postgres, and their C code.
(6) Fix dynlibs/interface

+ Check that it compiles with Solaris, HP-UX, Linux/Alpha, ...

+ Change version to 2.00 (June 2000)

+ Make -quietdec more quiet; drop the welcome greeting.

* Size of .ui files: sharing?

+ Problem compiling on LinuxPPC

2000-07-01:

+ (Don't do, this is a gcc macro extension)
 
  There is no snprintf on HPUX (it is a GNU-libc-extension),
  so I said in mosml.h

#define snprintf(dest, n, format, args...) sprintf(dest, format , ##
args)

   (all on a single line, the space before the last comma is
   necessary).
   This works with gcc (var-arg macros are another GNU extension,
   but in the compiler, which is what I have).
   I don't know whether mosml.h is a good place to put this line,
   but this file is just included by those *.c who use snprintf.
   Maybe the config stuff should check for it's existence
   (or even provide an implementation for people with crippled
   libcs).

+  src/doc/helpsigs/Makefile redefines MOSMLHOME, overriding
   a possibly different value from src/Makefile.inc.

+  install.txt says in (8) to look for dynlib stuff in (4),
   but this is in (5). I think the upper items were renumbered
   without incrementing the reference.
   [Not a mistake, but unclarity]

2000-08-07: 

* Binarymap (and Binaryset etc) based on Doug's Bin234map.
  Should admit interval queries a la sml/besked/Datemap:

   datatype 'key interval =
       All
     | From of 'key
     | To of 'key
     | FromTo of 'key * 'key

   val getAll : ('key, 'a) dict * 'key interval -> ('key * 'a) list

  such that  getAll dict All  is  equivalent to  listItems dict.

  The complexity of getAll dict intv should be O(log(N) + M) where N
  is the number of items in the dict, and M is the number of items in
  the answer.

  Also useful:

  val getMin : ('key, 'a) dict * 'key interval -> ('key * 'a) option
  val getMax : ('key, 'a) dict * 'key interval -> ('key * 'a) option

  which return the element with the least (resp. the largest) key in
  the interval, if any.  Thus

  getMin dict intv = (SOME (List.hd (getAll dict intv)) handle Empty => NONE
  getMax dict intv = (SOME (List.last (getAll dict intv)) handle Empty => NONE

  But the complexity of getMin dict intv and getMax dict intv should
  be O(log(N)) where N is the number of items in the dict.

  Also useful: a general lookup/insert/update/delete function 
   val peekMap : ('key, 'a) dict * 'key * ('a option -> 'a option) -> unit
  such that 

	peekMap(d, k, f) computes res = f(SOME v) if k is in dict with
        value v, and computes res = f(NONE) otherwise.  Subsequently, if 
	res = SOME r, it inserts/updates k in dict to r, and if res = NONE, 
	removes k from dict.

* Httpclient module

* Inet name queries etc

* 2000-08-10 #line comments for machine-generated mosml code:

--------------------------------------------------
From: Norman Ramsey <nr@eecs.harvard.edu>

I wonder if there's any chance of supporting some form of #line numbering.
Objective Caml supports the C style, i.e., 

# 27 "bits.nw"

 
Here is the style we have used in STandard ML of New Jersey:

(*#line 182 "mlscheme.nw"*)type name = string
type 'value simplemap = (name * 'value ref) list
val emptyMap : 'a simplemap = []


I'd be delighted if there were some way to get one of these
conventions, or a similar convention, into Moscow ML.
Do let me know what you think.
--------------------------------------------------

One way to implement this (2000-08-11): Maintain a table of the source
positions (byte offsets) at which #line directives occur (could be a
dynamic array; the positions would automatically be sorted increasing
and thus be suitable for binary search).  Whenever a message with
start and end locations xL and xR is to be emitted, look up the most
recent #line directive at or preceding xL.  Scan the source file until
xL, then reset the line counter to the line number indicated by that
#line directive and set the filename, then continue as usual.  This
ignores any #line directives between xL and xR.

The lexer should recognize the special comments of form 
(*#line n... "x..."*) 
where n... is a non-negative decimal number, x... is a string of
characters (in which an occurrence of *) is taken to be part of the
file name, presumably?).  In SML/NJ nothing can separate the terminal
quote (") and the asterisk (*) in the closing comment bracket.

?1 Must a #line directive appear at the very beginning of a line?  In
   SML/NJ: yes (but this makes lexing 

?2 Should a #line directive inside a comment be ignored?  In SML/NJ: yes.

* IntInt.int should be an equality type

* mosmlyac generates non-sml compliant signatures (local in end)

* 2000-09-22 Jeremy Dawson:

- datatype thing = / of int * int ;
datatype thing = / of int * int
- infix / ; 
infix /
- 1 / 2;
val it = 1 / 2 : thing

I find the SML/NJ output easier.
Would it be worth considering for MosML?


* 2000-09-22 Jeremy Dawson:

The command 
mosmlc -c a.sml b.sml c.sml d.sml e.sml f.sml g.sml h.sml i.sml j.sml
compiles all these files, in such a way that
load "j" ; 
loads all the others even though it doesn't depend on them.
Is there a reason for this?
If so, could the fact be mentioned in the documentation?
(At present, when load "x" can cause behaviour that bears no relation
to anything in x.sml or any other unit that x depends on,
which is very difficult to diagnose).

* 2000-10-04 Jakob Lichtenberg:

Output fra mosmlc -standalone kan ikke meningsfuldt strippes, idet
strip fjerner al bytekoden, saa kun camlrunm bliver tilbage!

Find ud af hvordan ELF-formatet er opbygget, og saet stoerrelsen
korrekt, saa strip ikke mutilerer den linkede fil.  See GNU binutils in info.

Maaske 
	objcopy --add-section BYTECODE=<bytecodefile> camlrunm mosmlout

Nej, duer ikke, for der ligger noget indeksinformation i enden af en
ELF fil...

Maaske der findes en C-funktion til at laese et navngivet segment fra
en linket fil, f.eks. et segment kaldet BYTECODE.

size -A mlsexe kan fortaelle hvor store de enkelte sektioner er.

* 2000-10-20:  SML Basis Library 

+ zillions of changes already made
+ Word8Array, CharArray   -- remove and simplify
+ Word8Vector, CharVector -- remove and simplify
+ test/vector.sml -- many missing cases
+ Word8ArraySlice, CharArraySlice -- add
+ Word8VectorSlice, CharVectorSlice -- add
+ Negative Time values -- how?  Use reals, represent time as 
  whole number of microseconds since the epoch (possibly negative).  
  This gives exact times in a range of 2^52 = 4.503.599.627.370.496, 
  that is, microsecond resolution from 1828 till 2112.
* Extended date offset range?
+ ~ (ones-complement) in Word, Word8
+ Timer -- do not include GC time, add new function
+ Process.status not equality type
* Unix structure -- various changes


+ 2000-10-20: Mosml library

Further unify Mysql and Postgres signatures; must match a common Db
signature.

* 2000-10-31: Stephen T Weeks (comp.lang.ml)
Date: 30 Oct 2000 15:17:52 GMT

There's definitely some differences amongst SML implementations
regarding type specifications in signatures.  Consider the following
two programs.

(* program 1 *)
signature S =
   sig
      type t
      and u = int
   end

(* program 2 *)
signature S =
   sig
      type t = int
      and u = t
   end

According to the Definition (pages 14, 35 (rule 80), and 59 (figure
19)), program 1 should be rejected as a syntax error and program 2
should be accepted (because of the expansion explained in the previous
post.  Here's a comparison of five different SML implementations on
the two programs.

The Definition		reject	accept

ML Kit Version 3	reject	accept
MLton 20000906		accept	reject
Moscow ML 2.00		reject	reject
Poly/ML 4.0		accept	reject
SML/NJ 110.0.6		accept	accept
SML/NJ 110.29		accept	accept

As you can see, all four possibilities are achieved.

Of the five compilers, only the ML Kit gets both programs right,
Moscow ML and SML/NJ get one right (and disagree with each other), and
MLton and PolyML get both wrong.

+ Exception Option should be available in the top-level by default.
  Should go in src/compiler/Smlperv.sml and in runtime/globals.h
  Fixed Jan 2001.

* 2001-02-16: Dynamic linking under MacOS X.  See man ld, man dyld.

  cc -dynamiclib?

  #include <mach-o/dyld.h>
  
  Documentation/DeveloperTools/Compiler

  man 3 dyld

+ 2001-02-27: Ken: Jeg mener at foelgende funktion er hale rekursiv,
men Mosml er ikke enig med mig (den oversaetter iht det rekursive kald
til fitting til et apply):

--------
fun fitting [] left          = true
  | fitting (s :: rest) left = 
    left >= 0 andalso
    (case s of
         "\n" => true
       | _    => fitting rest (left - size s))
--------
(og ligeledes med orelse)

Årsag: I kodegenereringen for Landalso og Lorelse i Back.sml mangler
der det tilfælde hvor oversættelsestids-continuation starter med
Klabel :: Kreturn _ :: ... 

Fixed by updating addPop to handle the case where C is Klabel :: Kreturn.

* 2001-04-02: Streamline the (Basis Library) test cases so that they
  can be effectively used also by the ML Kit.

  Avoid inclusion by `use'.  Instead open Testaux and open other
  needed structures.  Batch compile the test files, and load them to
  produce the test output.  Rename check' to check, and give it
  one more argument: a string indicating the name of the test.

* 2001-05-11: Ken 

  I've made a new mosml windows installer it is available from:
        http://www.it.edu/~kfl/tmp/mosml-setup-2_00.exe
 
 I've tested it on my laptop with windows 2000 where it seems to work
 fine, and I would like if you could help me testing it like last time.  

* 2001-05-22: Date: 21 May 2001 14:28:31 +0200
              From: Martin Elsman <mael@dina.kvl.dk>
Subject: Int overflow

Hej Peter,

Jeg har modificeret koden til scanning og formattering af små
heltalskonstanter således at Overflow ikke forekommer, som i følgende
session:

  mael@daffy> mosml -P full
  Moscow ML version 2.00 (June 2000)
  Enter `quit();' to quit.
  - Int.fmt StringCvt.DEC (valOf Int.minInt);
  ! Uncaught exception: 
  ! Overflow
  - Int.fmt StringCvt.BIN (valOf Int.minInt);
  ! Uncaught exception: 
  ! Overflow
  - Int.fromString "~1073741824";
  ! Uncaught exception: 
  ! Overflow
  - 

Funktionen conv i strukturen Int ændres til:

  fun conv radix i =
    if SOME i = minInt then          (* Be careful not to Overflow *)
      let fun tag s1 s2 = if precision = SOME 31 then s1 else s2
      in case radix
	   of 2 => tag "~1000000000000000000000000000000" "~10000000000000000000000000000000"
	    | 8 => tag "~10000000000" "~20000000000"
	    | 10 => tag "~1073741824" "~2147483648"
	    | 16 => tag "~40000000" "~80000000"
	    | _ => raise Fail "conv"
      end
    else
      let fun h 0 res = res
	    | h n res = h (n div radix) (prhex (n mod radix) :: res)
	  fun tostr n = h (n div radix) [prhex (n mod radix)]
      in implode (if i < 0 then #"~" :: tostr (~i) else tostr i) 
      end

Funktionen dig1 i strukturen Int ændres til:

    fun dig1 sgn NONE = NONE
      | dig1 sgn (SOME (c, rest)) =
      let fun digr (res:int) next_val src =
	case getc src
	  of NONE => SOME (res, src)
	   | SOME (c, rest) => if isDigit c then digr (next_val(factor, res, hexval c)) next_val rest
			       else SOME (res, src)
	  val next_val =
	    if sgn = 1 then fn (factor, res, hv) => factor * res + hv
	    else fn (factor, res, hv) => factor * res - hv
      in if isDigit c then digr (sgn * hexval c) next_val rest else NONE 
      end


 * 2001-05-15: the binaries for MacOS X [Version 2.00 for Macintosh
PPC with MacOS X (without dynamic libraries)] and they fail with the
following error:
 
matt@mec30:~/Downloads/mosml/bin $ ./mosml
./mosml: no such file or directory: /Users/lcp/mosml/bin/camlrunm [11]
                                                
 * 2001-05-25: From: Konrad Slind <Konrad.Slind@cl.cam.ac.uk>

Surprised I was, when a student sent me this, in contradiction of
something I said in a supervision:
 
    Moscow ML version 2.00 (June 2000)
    Enter `quit();' to quit.
    - fun f g g = g;
    > val ('a, 'b) f = fn : 'a -> 'b -> 'b
 
[Presumably wrong according to the Definition's appendix on derived
forms]

 * 2001-05-17: jeremy@discus.anu.edu.au

ON page 8, (sec 3.4), under description of loadPath,
it says (2nd sentence)
This variable affects the load, loadOne and use functions.
 
It seems from my experiments that it also affects the
compile, compileStructure and compileToplevel functions.      


 * 2001-05-25: Ken Friis Larsen <kfl@it.edu>
 
I've found a small bug in mosml's handling of signatures.  This should
be correct SML:
 
signature COL = sig type elem type col end
signature INTCOL1 = COL where type col = int list
                       where type elem = int
signature INTCOL2 = COL where type elem = int
                        where type col = int list
signature INTERM = COL where type elem = int
signature INTCOL3 = INTERM where type col = int list    

 * 2000-06-05: Henning Makholm:

Could future versions of mosmlyac please take a consistent stance
about whether they support rules without actions? The current one
glefully processes the grammar file without error, but produces a
parser that raises Fail when it tries to reduce the actionless rule.
 
If the nonterminal has a type definition, mosmlyac warns that the
default action produces an undefined value - in reality the default
action (used in the definition of yyact in the generated gode) throws
an exception. If the nonterminal does not have a type defintion
(as in the typescript below), no warning at all is produced - but
the default action still throws an exception...   

$ cat foo.grm
%{
%}
  %token FOO
  %type <int> S
  %start S
%%
  S : T { 42 } ; T : FOO ;
%%
$ cat bar.sml
val _ = foo.S (fn _ => foo.FOO) (Lexing.createLexerString "")
$ mosmlyac -v foo.grm
$ mosmlc foo.sig foo.sml bar.sml

* 2001-06-08:jeremy@discus.anu.edu.au   

Last year I emailed you about what turns out to be a related
problem - I'd assumed that
mosmlc -c A.sml B.sml C.sml
would do the same as
mosmlc -c A.sml
mosmlc -c B.sml
mosmlc -c C.sml
but in fact fake dependencies were introduced there also.    
I wonder if this issue warrants a mention in the documentation.

* 2001-06-11: Michael Norrish <Michael.Norrish@cl.cam.ac.uk>   

The system-administrators here dislike the fact that the mosml2.0 RPM
 
  "installs files into /usr/bin and /usr/mosml and is not
  relocatable."
 
Rather than use this, they then installed the binary version, without
then setting things up as per the instructions, and what they've
installed doesn't work well.
 
Also, the instructions at
 
  ftp://ftp.dina.kvl.dk/pub/mosml/install-linux.txt
 
don't say anything about the symbolic link at <mosmldir>/lib/camlrunm,
which seems to be used when linking.                 

[The latter is an RPM-problem / Peter]

* 2001-06-21: Martin Elsman <mael@dina.kvl.dk>

Det ser ud som om Moscow ML ikke binder Option og Span som exception
konstruktører på top-niveau, som foreskrevet i
 
  http://www.dina.kvl.dk/%7Esestoft/sml/top-level-chapter.html

* 2001-07-17:  Stephen Weeks <sweeks@intertrust.com>
 
Mosml accepts the following program.  It should report an error because x is
bound twice in the same valbind.
 
val x = 13
and rec x = fn () => ()     

* 2001-08-02: PS to check up on Buffer.{sig, sml} from Ken.

* 2001-08-02: PS to check up on Ken's red-black tree implementation.
              Compare with Doug's 2-3-4 maps.
  2001-10-15:
 
   Add interval operations (done, but not tested).
   Add hash codes.
   Ensure reasonable naming schemes, short names:

    Rbset, Rbmap		functional (persistent)
    Hashset, Hashmap		imperative

   Create an SML version of the nfa-to-dfa conversion procedure, using
   a hashmap of treesets etc.

  Bugs found:
   isSubset was wrong for empty first arg and non-empty second arg

* 2001-08-14: Michael Norrish, email

  There doesn't seem to be any nice way of finding the key of a
  Binary map that maps to the least value (say the range is int).
  
* 2001-10-18: Michael Norrish: 

  * enable call to system prettyprinter from installed prettyprinters,

    This is best done by introducing a pseudopolymorphic function 

	Meta.fmtVal : 'a -> (ppstream -> unit) -> unit
 
    that takes as argument a value and a ppstream and prints on that, 
    exactly as Rtvals.prVal (which implements printVal) already does.

    The most sensible thing would be to pass the PP.ppstream to prVal
    and all its helpers, and replace msgString etc from Mixture with
    appropriate function calls.  This is a bit tedious but perfectly
    doable.

  * prettyprint infix constructors as infix

    This should be done in the very last branch of prVal, checking for
    arity = 2 and using Units.pervasiveInfixBasis to look up the
    fixity of the constructor.  I wonder whether the prior logic in
    prVal would handle right-associative operators correctly?  If it
    doesn't, that just means there will be excess parentheses in some
    cases.  The prior precedece logic of prVal would need to be fixed
    to fit the precendece actually use in SML.

* 2001-10-29 Don Sanella:

> According to the Moscow ML library documentation, various functions
> in TextIO may raise the exception Io.Io.  According to the SML Basic
> Library that is supposed to be IO.Io.  There appears to be a library
> module called IO, since    load "IO"    doesn't complain, and it
> contains an exception IO.Io, but there is no section about the IO
> module in the Moscow ML library documentation.
   
* 2001-10-29 Michael Norrish:

It would be very nice to have a time-out function available.
Something like
 
  timeout : time -> ('a -> 'b) -> 'a -> 'b
 
which raises an exception if the time allotted expires.
 
This would make proof strategies that combined black-box components a
positive pleasure to write.  It would need to work both interactively
and in compiled code.
 
Also, it would be nice to have the magic (involving prim_val) that
makes the Interrupt exception "work" in executables (i.e., catches       
Ctl-C) properly documented.
 
Currently I just copy
 
  prim_val catch_interrupt : bool -> unit = 1 "sys_catch_break";
  val _ = catch_interrupt true;
 
from file to file without understanding what I'm doing.       

* 2001-11-05 Nils Andersen: integer Overflow when computing ~32768*32768.

* 2001-11-05 Konrad Slind: Is Splaymap.transform tail-recursive?  No.
  Is the problem that the trees get very unbalanced?  Probably.

* 2001-11-13: Delete Closure_wosize from mlvalues.h and from signals.h
  (where an empty `env' is allocated; strictly speaking an
  always-ignored () : unit, which is a mistake).

* 2001-12-17: Mosmlcgi and Mosmlcookie suggestions from Hans Molin.

* 2001-12-26: Stanislaw Skowron, see skowron-bug.sml: excess
  polymorphism leads to segmentation fault.

* 2002-01-15: Binarymap desiderata.  

  * Benchmark Ken's red-black vs Doug's 234-trees.
 
  * Konrad wants a way to map a map to something else by a function f,
    while preserving the key order.  A function such as 
      remap : ('a -> 'c) * ('b -> 'd) -> ('a,'b)dict -> ('c,'d)dict 
    which must be applied only to functions f that satisfy
      compare1 k1 k2 = compare2 (f k1) (f k2)
    where compare1 : 'a * 'a -> order and compare2 : 'b * 'b -> order
    This should be done in linear time, not using inserts all over the 
    place again.

  * Ken suggests: The new key ('c) might depend on the data ('b).
    Actually the type should be:
 
        val genmap : ('c * 'c -> order) -> ('a * 'b -> 'c * 'd)
                                        -> ('a,'b)dict -> ('c,'d)dict
 
    because we need the new compare function to construct the result
    dist.  If I should implement genmap for RB trees then I'd first
    genrate a list of the mapped elements, check that the list is
    sorted and then use fromSortedList.  But then I can be over
    defensive in my (SML) programming.


* 2002-02-22: Ordered map desiderata: From: Michael Norrish
<Michael.Norrish@cl.cam.ac.uk>
 
The various map datatype implementations in the mosml library should
include a function to update a value at a particular key.  This would
then save a traversal of the tree  (well, not in the case of Splay
maps I guess).
 
  val fupdate : ('a,'b) dict -> ('b -> 'b) -> 'a -> ('a,'b)dict
 
This sort of thing is useful when maintaining a map of counts, where
you want to be incrementing values all over the place.
 
The most efficient alternative at the moment would seem to be a
hashtable of references.

* 2002-02-26: David.Richerby@cl.cam.ac.uk       

I found the following in Moscow ML version 2.00 on a RedHat 7.1
machine while trying to fix a broken program.  Consider the following,
where [^D] on the sixth line indicates that I pressed ctrl-D at that
point rather than return.
 
$ mosml
Moscow ML version 2.00 (June 2000)
Enter `quit();' to quit.
- fun app (f: int->int) x = f x;
> val app = fn : (int -> int) -> int -> int
- fun bug f x y = (app (app f x)) y;[^D]! Toplevel input:
! fun bug f x y = (app (app f x)) y;<EOF>
!                       ^^^^^^^^^^^^
! Type clash: expression of type
!   int
! cannot have type
!   int -> int
- quit();

sestoft: The abstract syntax tree is annotated with source code
positions which are used when reporting errors.  Somehow the end of
the subtree (app f x) is wrong.  Probably this is due to some mistake
in mosml/src/mosmllib/Parsing.sml or (more likely) in
mosml/src/runtime/parsing.c.  I'll investigate.
 
I've never encountered the problem myself, possibly because emacs
always appends a newline at the end of source code files when saved.

* 2002-04-08: MacOS X on swallow.al.cl.cam.ac.uk

Compiler is cc, not gcc.

Added option -traditional-cpp to CC.

Added option -S to strip.

~/bin is on PATH, but the shell needs a rehash to be able to find
newly installed programs there.

The mosmllib/test/filesys.sml tests test6e test6f test8d test8h fail
because realpath and fullpath are too intelligent on MacOS X.  Changed
the tests to accept the results.

Dynamic linking is done using the dlcompat package from
http://sourceforge.net/projects/fink/ which appears to be preinstalled
in /sw/include and /sw/lib (but undocumented); it gives an interface
similar to dlopen from Solaris/Linux.  

Notes:

 + If camlrunm is stripped, the symbols defined in it are not linkable.

 + Must link files that are to be linked dynamiclly must be linked
   using cc, not ld, otherwise symbol dyld_stub_binding_helper is
   missing.

 + The compiler (or linker?) inserts an underscore in front of
   symbols it attempts to look up.  Wonderful.  This has been fixed by
   a MacOS X specific version of dlsym() in runtime/dynlib.c.  We
   recognize MacOS X as #if defined(__APPLE__) && defined(__MACH__)
   and hope this is adequate.

Now the crypt, interface, munix, mregex, msocket, mgdbm examples work.
The remaining examples mgd mpq intinf mmysql require extra software.
Callbacks work as well.

* 2002-05-11: From slind@cs.utah.edu Sat May 11 03:59:14 2002

  This is a rushed note about some things I have on my MoscowML wish
list. Just thought I'd scribble them down before I forgot:

  1. A type of SML abstract syntax trees, with a parser that produces
     them.

  2. An evaluator for such ASTs (something like NJSML's eval_string, or
     whatever it's called). Something like

      evalAST : AST -> unit

     that wouldn't return values, but would evaluate the argument (in
     the current environment) and update the current environment.

  3. The left margin on the prettyprinter sometimes gets way too far
     over on the page. I remember fixing the NJSML prettyprinter to
     automatically reset the left margin once it got past 2/3 of the
     width of the page.

For 1,2 the motivation is that HOL is a collection of libraries sitting
on top of ML. One of those libraries lets me define (total) logical
functions that look like ML programs (with pattern matching, etc). I'd
like to be able to generate ML code for these within a session. I have a
hack using references and writing to files and calling "use", but that
of course only works interatively. Hmm, I've got to go now, but will try
to write more coherently tomorrow.

2002-07-25: The Postgres interface now works with PostgreSQL 7.2
provided databases are created with LATIN1 or another 8-bit encoding,
and recognizes the int8 type (returned by COUNT).

