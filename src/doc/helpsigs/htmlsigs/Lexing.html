<HTML><HEAD><TITLE>Structure Lexing</TITLE></HEAD>
<BODY BGCOLOR="#fbf2e7">
<H1>Structure Lexing</H1>
<HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<PRE>
<A NAME="line0"></A>(* Lexing -- run-time library for lexers generated by mosmllex             *)
<A NAME="line1"></A>(* Closely based on the library for camllex.  Copyright 1993 INRIA, France *)
<A NAME="line2"></A>
<A NAME="line3"></A>local open Obj in
<A NAME="line4"></A>
<A NAME="line5"></A>type <A HREF="#lexbuf-typ">lexbuf</A>
<A NAME="line6"></A>
<A NAME="line7"></A>val <A HREF="#createLexerString-val">createLexerString</A> : string -&gt; lexbuf
<A NAME="line8"></A>val <A HREF="#createLexer-val">createLexer</A>       : (CharArray.array -&gt; int -&gt; int) -&gt; lexbuf
<A NAME="line9"></A>
<A NAME="line10"></A>val <A HREF="#getLexeme-val">getLexeme</A>         : lexbuf -&gt; string
<A NAME="line11"></A>val <A HREF="#getLexemeChar-val">getLexemeChar</A>     : lexbuf -&gt; int -&gt; char
<A NAME="line12"></A>val <A HREF="#getLexemeStart-val">getLexemeStart</A>    : lexbuf -&gt; int
<A NAME="line13"></A>val <A HREF="#getLexemeEnd-val">getLexemeEnd</A>      : lexbuf -&gt; int
<A NAME="line14"></A>
<A NAME="line15"></A>(* For internal use in generated lexers: *)
<A NAME="line16"></A>
<A NAME="line17"></A>val dummyAction       : lexbuf -&gt; obj
<A NAME="line18"></A>val backtrack         : lexbuf -&gt; 'a
<A NAME="line19"></A>prim_val getNextChar  : lexbuf -&gt; char = 1 "get_next_char"
<A NAME="line20"></A>
<A NAME="line21"></A>prim_val getLexBuffer     : lexbuf -&gt; string           = 1 "field1"
<A NAME="line22"></A>prim_val getLexAbsPos     : lexbuf -&gt; int              = 1 "field2"
<A NAME="line23"></A>prim_val getLexStartPos   : lexbuf -&gt; int              = 1 "field3"
<A NAME="line24"></A>prim_val getLexCurrPos    : lexbuf -&gt; int              = 1 "field4"
<A NAME="line25"></A>prim_val getLexLastPos    : lexbuf -&gt; int              = 1 "field5"
<A NAME="line26"></A>prim_val getLexLastAction : lexbuf -&gt; (lexbuf -&gt; obj)  = 1 "field6"
<A NAME="line27"></A>
<A NAME="line28"></A>prim_val setLexAbsPos     : lexbuf -&gt; int -&gt; unit             = 2 "setfield2"
<A NAME="line29"></A>prim_val setLexStartPos   : lexbuf -&gt; int -&gt; unit             = 2 "setfield3"
<A NAME="line30"></A>prim_val setLexCurrPos    : lexbuf -&gt; int -&gt; unit             = 2 "setfield4"
<A NAME="line31"></A>prim_val setLexLastPos    : lexbuf -&gt; int -&gt; unit             = 2 "setfield5"
<A NAME="line32"></A>prim_val setLexLastAction : lexbuf -&gt; (lexbuf -&gt; obj) -&gt; unit = 2 "setfield6"
<A NAME="line33"></A>end
<A NAME="line34"></A>
<A NAME="line35"></A>(* 
<A NAME="line36"></A>   These functions are for use in mosmllex-generated lexers.  For
<A NAME="line37"></A>   further information, see the Moscow ML Owner's Manual.  For
<A NAME="line38"></A>   examples, see mosml/examples/lexyacc and mosml/examples/calc.
<A NAME="line39"></A>
   [<A NAME="lexbuf-typ"><B>lexbuf</B></A>] is the type of lexer buffers.  A lexer buffer is the
   argument passed to the scanning functions defined by the
   mosmllex-generated scanners.  The lexer buffer holds the current
   state of the scanner, plus a function to refill the buffer from the
   input.

   [<A NAME="createLexerString-val"><B>createLexerString</B></A> s] returns a lexer buffer which reads from the
   given string s. Reading starts from the first character in the
   string.  An end-of-input condition is generated when the end of the
   string is reached.

   [<A NAME="createLexer-val"><B>createLexer</B></A> f] returns a lexer buffer that will use the given
   function f for reading additional input.  When the lexer needs more
   characters, it will call the given function as (f carr n), where
   carr is a character array, and n is an integer.  The function
   should put at most characters or in carr, starting at character
   number 0, and return the number of characters actually stored.  A
   return value of 0 means end of input. 

   A lexer definition (input to mosmllex) consists of fragments of
   this form

      parse
          lhs1   { rhs1 }
        | lhs2   { rhs2 }
        | lhs3   { rhs3 }
        | ...

   where the lhs are regular expressions matching some string of
   characters, and the rhs are corresponding semantic actions, written
   in ML.  The following functions can be used in the semantic actions:

   [<A NAME="getLexeme-val"><B>getLexeme</B></A> lexbuf] returns the string matched by the left-hand side
   regular expression.

   [<A NAME="getLexemeChar-val"><B>getLexemeChar</B></A> lexbuf i] returns character number i in the matched
   string. 

   [<A NAME="getLexemeStart-val"><B>getLexemeStart</B></A> lexbuf] returns the start position of the matched
   string (in the input stream).  The first character in the stream
   has position 0.

   [<A NAME="getLexemeEnd-val"><B>getLexemeEnd</B></A> lexbuf] returns the end position, plus one, of the
   matched string (in the input stream).  The first character in the
   stream has position 0.  
*)

</PRE><HR><TABLE WIDTH=100%><TR ALIGN = CENTER>
<TH><A HREF="idIndex.html">Identifier index</A>
<TH><A HREF="index.html">Structure index</A>
</TABLE><HR>
<BR><EM><A HREF="http://www.dina.kvl.dk/~sestoft/mosml.html">Moscow ML</A> 2.00.1</EM></BODY></HTML>
